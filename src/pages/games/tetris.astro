---
import Layout from '../../layouts/Layout.astro';
---

<Layout title="Tetris">
  <h1 class="text-3xl font-bold my-6">Tetris</h1>
  <div class="flex gap-4">
    <canvas id="board" width="300" height="600"></canvas>
    <div class="space-y-4">
      <div>
        <p class="font-bold">Next</p>
        <canvas id="next" width="120" height="120"></canvas>
      </div>
      <div>
        <p class="font-bold">Hold</p>
        <canvas id="hold" width="120" height="120"></canvas>
      </div>
      <div class="space-y-2">
        <p>Score: <span id="score">0</span></p>
        <p>Lines: <span id="lines">0</span></p>
        <p>Level: <span id="level">0</span></p>
        <p>High Score: <span id="highscore">0</span></p>
      </div>
    </div>
  </div>
  <div class="md:hidden mt-4 flex flex-wrap gap-2">
    <button id="btn-left" class="px-4 py-2 bg-gray-700 text-white rounded">◀</button>
    <button id="btn-rotate-ccw" class="px-4 py-2 bg-gray-700 text-white rounded">⟲</button>
    <button id="btn-rotate" class="px-4 py-2 bg-gray-700 text-white rounded">⟳</button>
    <button id="btn-right" class="px-4 py-2 bg-gray-700 text-white rounded">▶</button>
    <button id="btn-drop" class="px-4 py-2 bg-gray-700 text-white rounded">⬇</button>
    <button id="btn-hold" class="px-4 py-2 bg-gray-700 text-white rounded">H</button>
  </div>
  <div class="mt-6">
    <h2 class="font-bold">Leaderboard</h2>
    <h3 class="font-semibold">Local</h3>
    <ol id="leaderboard-local" class="list-decimal ml-6"></ol>
    <h3 class="font-semibold mt-4">Global</h3>
    <ol id="leaderboard-global" class="list-decimal ml-6"></ol>
  </div>
  <script>
const COLS = 10;
const ROWS = 20;
const SIZE = 30;

const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');

const nextCanvas = document.getElementById('next');
const nextCtx = nextCanvas.getContext('2d');

const holdCanvas = document.getElementById('hold');
const holdCtx = holdCanvas.getContext('2d');
function scaleForHiDPI(c, context) {
  const dpr = window.devicePixelRatio || 1;
  if (dpr !== 1) {
    c.style.width = c.width + 'px';
    c.style.height = c.height + 'px';
    c.width = Math.floor(c.width * dpr);
    c.height = Math.floor(c.height * dpr);
    context.scale(dpr, dpr);
  }
}

scaleForHiDPI(canvas, ctx);
scaleForHiDPI(nextCanvas, nextCtx);
scaleForHiDPI(holdCanvas, holdCtx);

// --- User & High Score ---
let username = localStorage.getItem('tetris_username');
while (!username) {
  username = prompt('Enter a username:')?.trim();
}
localStorage.setItem('tetris_username', username);

let highScore = parseInt(localStorage.getItem('tetris_highscore') || '0', 10);

function loadLocalLeaderboard() {
  try {
    return JSON.parse(localStorage.getItem('tetris_leaderboard')) || [];
  } catch {
    return [];
  }
}

function saveLocalLeaderboard(data) {
  localStorage.setItem('tetris_leaderboard', JSON.stringify(data));
}

function renderLocalLeaderboard(data) {
  const list = document.getElementById('leaderboard-local');
  list.innerHTML = data.map((e) => `<li>${e.name}: ${e.score}</li>`).join('');
}

function renderGlobalLeaderboard(data) {
  const list = document.getElementById('leaderboard-global');
  list.innerHTML = data.map((e) => `<li>${e.name}: ${e.score}</li>`).join('');
}

async function fetchGlobalLeaderboard() {
  try {
    const res = await fetch('/api/tetris-scores');
    const data = await res.json();
    renderGlobalLeaderboard(data);
  } catch (e) {
    console.error('Failed to load global leaderboard', e);
  }
}

let localLeaderboard = loadLocalLeaderboard();
renderLocalLeaderboard(localLeaderboard);
fetchGlobalLeaderboard();

// --- Scoring ---
let score = 0;
let lines = 0;
let level = 0;
let dropInterval = 800; // ms per row at level 0

function updateSpeed() {
  dropInterval = Math.max(100, 800 - level * 80);
}

const $score = document.getElementById('score');
const $lines = document.getElementById('lines');
const $level = document.getElementById('level');
const $high = document.getElementById('highscore');

function updateHUD() {
  $score.textContent = score;
  $lines.textContent = lines;
  $level.textContent = level;
  $high.textContent = highScore;
}

function addScore(cleared) {
  // official: single=100, double=300, triple=500, tetris=800; scaled by (level+1)
  const table = [0, 100, 300, 500, 800];
  score += table[cleared] * (level + 1);
  lines += cleared;

  // level up every 10 lines
  const target = (level + 1) * 10;
  if (lines >= target) {
    level++;
    updateSpeed();
  }
  updateHUD();
}


// --- Playfield state (0 = empty; >0 = color index) ---
const board = Array.from({length: ROWS}, () => Array(COLS).fill(0));

// Simple palette: indices 1..7 map to colors
const COLORS = [
  null,
  '#00f0f0', // 1 cyan
  '#0000f0', // 2 blue
  '#f0a000', // 3 orange
  '#f0f000', // 4 yellow
  '#00f000', // 5 green
  '#a000f0', // 6 purple
  '#f00000', // 7 red,
];

// --- Gravity timing ---
let lastTime = 0;
let dropCounter = 0;
let lockTimer = 0;
const LOCK_DELAY = 500; // ms before a grounded piece locks


// Draw one cell
function drawCell(x, y, color, context = ctx, size = SIZE) {
  const px = x * size;
  const py = y * size;

  // base
  context.fillStyle = color;
  context.fillRect(px, py, size, size);

  // tiny bevel for a bit of depth
  context.strokeStyle = '#111';
  context.strokeRect(px + 0.5, py + 0.5, size - 1, size - 1);
}

// --- Tetromino definitions (cell values match color indices) ---
const SHAPES = {
  I: [[1, 1, 1, 1]],
  J: [[2, 0, 0], [2, 2, 2]],
  L: [[0, 0, 3], [3, 3, 3]],
  O: [[4, 4], [4, 4]],
  S: [[0, 5, 5], [5, 5, 0]],
  T: [[0, 6, 0], [6, 6, 6]],
  Z: [[7, 7, 0], [0, 7, 7]],
};

// SRS wall-kick data
const JLSTZ_KICKS = {
  0: {
    1: [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]],
    "-1": [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]],
  },
  1: {
    1: [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]],
    "-1": [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]],
  },
  2: {
    1: [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]],
    "-1": [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]],
  },
  3: {
    1: [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]],
    "-1": [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]],
  },
};

const I_KICKS = {
  0: {
    1: [[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]],
    "-1": [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]],
  },
  1: {
    1: [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]],
    "-1": [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]],
  },
  2: {
    1: [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]],
    "-1": [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]],
  },
  3: {
    1: [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]],
    "-1": [[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]],
  },
};

// Rotate a matrix CW (dir=1) or CCW (dir=-1)
function rotate(mat, dir = 1) {
  const h = mat.length, w = mat[0].length;
  const res = Array.from({length: w}, () => Array(h).fill(0));
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      if (dir === 1) res[x][h - 1 - y] = mat[y][x];
      else res[w - 1 - x][y] = mat[y][x];
    }
  }
  return res;
}

// Active piece state and 7-bag queue
let piece = null;
let next = null;
let hold = null;
let holdUsed = false;

let bag = [];

function refillBag() {
  bag = Object.keys(SHAPES);
  for (let i = bag.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [bag[i], bag[j]] = [bag[j], bag[i]];
  }
}

function getNextPiece() {
  if (!bag.length) refillBag();
  const t = bag.pop();
  return { matrix: SHAPES[t].map(row => row.slice()), type: t };
}

function renderPreview(context, mat, canvas) {
  context.clearRect(0, 0, canvas.width, canvas.height);
  if (!mat) return;
  const offsetX = Math.floor((4 - mat[0].length) / 2);
  const offsetY = Math.floor((4 - mat.length) / 2);
  for (let y = 0; y < mat.length; y++) {
    for (let x = 0; x < mat[y].length; x++) {
      const v = mat[y][x];
      if (!v) continue;
      drawCell(x + offsetX, y + offsetY, COLORS[v], context);
    }
  }
}

// Draw any matrix onto the canvas at (offX, offY)
function drawMatrix(mat, offX, offY) {
  for (let y = 0; y < mat.length; y++) {
    for (let x = 0; x < mat[y].length; x++) {
      const v = mat[y][x];
      if (!v) continue;
      const gx = offX + x;
      const gy = offY + y;
      if (gy >= 0) { // allow spawning slightly above visible area
        drawCell(gx, gy, COLORS[v]);
      }
    }
  }
}

// Spawn the next tetromino from the bag
function spawn() {
  const { matrix, type } = next;
  piece = {
    matrix,
    x: Math.floor((COLS - matrix[0].length) / 2),
    y: -1, // start just above the board so tall pieces slide in
    type,
    rot: 0,
  };
  next = getNextPiece();
  renderPreview(nextCtx, next.matrix, nextCanvas);
  holdUsed = false;
  renderPreview(holdCtx, hold ? hold.matrix : null, holdCanvas);
  lockTimer = 0;
  dropCounter = 0;
}

function holdPiece() {
  if (holdUsed) return;
  if (hold) {
    const temp = { matrix: piece.matrix, type: piece.type };
    piece.matrix = hold.matrix;
    piece.type = hold.type;
    piece.x = Math.floor((COLS - piece.matrix[0].length) / 2);
    piece.y = -1;
    hold = temp;
  } else {
    hold = { matrix: piece.matrix, type: piece.type };
    spawn();
  }
  holdUsed = true;
  lockTimer = 0;
  dropCounter = 0;
  renderPreview(holdCtx, hold.matrix, holdCanvas);
  render();
}

// Check if matrix at (offX, offY) is a valid position (no collisions)
function isValidPosition(mat, offX, offY) {
  for (let y = 0; y < mat.length; y++) {
    for (let x = 0; x < mat[y].length; x++) {
      const v = mat[y][x];
      if (!v) continue;

      const gx = offX + x;
      const gy = offY + y;

      // outside left/right/bottom
      if (gx < 0 || gx >= COLS || gy >= ROWS) return false;

      // above top is allowed (spawn region)
      if (gy < 0) continue;

      // hit an occupied cell
      if (board[gy][gx]) return false;
    }
  }
  return true;
}

// Merge the active piece into the board (lock it)
function mergePiece() {
  const {matrix, x: offX, y: offY} = piece;
  for (let y = 0; y < matrix.length; y++) {
    for (let x = 0; x < matrix[y].length; x++) {
      const v = matrix[y][x];
      if (!v) continue;
      const gx = offX + x;
      const gy = offY + y;
      if (gy >= 0) board[gy][gx] = v;
    }
  }
}

function clearLines() {
  let cleared = 0;
  for (let y = ROWS - 1; y >= 0; y--) {
    if (board[y].every(v => v !== 0)) {
      board.splice(y, 1);                 // remove the full row
      board.unshift(Array(COLS).fill(0)); // add empty row at top
      cleared++;
      y++; // re-check same y index (since rows shifted down)
    }
  }
  return cleared; // 0..4
}


function tryMove(dx, dy) {
  const nx = piece.x + dx;
  const ny = piece.y + dy;
  if (isValidPosition(piece.matrix, nx, ny)) {
    piece.x = nx;
    piece.y = ny;
    lockTimer = 0;
    return true;
  }
  return false;
}

function tryRotate(dir = 1) {
  if (piece.type === 'O') return true;
  const rotated = rotate(piece.matrix, dir);
  const oldRot = piece.rot;
  const newRot = (oldRot + (dir === 1 ? 1 : 3)) % 4;
  const table = piece.type === 'I' ? I_KICKS : JLSTZ_KICKS;
  const kicks = table[oldRot][dir === 1 ? 1 : '-1'];
  for (const [kx, ky] of kicks) {
    const nx = piece.x + kx;
    const ny = piece.y + ky;
    if (isValidPosition(rotated, nx, ny)) {
      piece.matrix = rotated;
      piece.x = nx;
      piece.y = ny;
      piece.rot = newRot;
      lockTimer = 0;
      return true;
    }
  }
  return false;
}


// Full render: background, placed blocks, grid
function render() {
  // background
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, COLS * SIZE, ROWS * SIZE);

  // draw placed cells
  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      const v = board[y][x];
      if (v) drawCell(x, y, COLORS[v]);
    }
  }

  // subtle grid lines
  ctx.strokeStyle = '#222';
  ctx.lineWidth = 1;
  for (let x = 0; x <= COLS; x++) {
    ctx.beginPath();
    ctx.moveTo(x * SIZE, 0);
    ctx.lineTo(x * SIZE, ROWS * SIZE);
    ctx.stroke();
  }
  for (let y = 0; y <= ROWS; y++) {
    ctx.beginPath();
    ctx.moveTo(0, y * SIZE);
    ctx.lineTo(COLS * SIZE, y * SIZE);
    ctx.stroke();
  }

  // draw active piece on top
  if (piece) {
    drawMatrix(piece.matrix, piece.x, piece.y);
  }

}

async function lockPiece() {
  mergePiece();
  const cleared = clearLines();
  if (cleared) addScore(cleared);
  spawn();
  if (!isValidPosition(piece.matrix, piece.x, piece.y)) {
    if (score > highScore) {
      highScore = score;
      localStorage.setItem('tetris_highscore', highScore.toString());
    }
    localLeaderboard.push({ name: username, score });
    localLeaderboard.sort((a, b) => b.score - a.score);
    localLeaderboard = localLeaderboard.slice(0, 10);
    saveLocalLeaderboard(localLeaderboard);
    renderLocalLeaderboard(localLeaderboard);
    try {
      const res = await fetch('/api/tetris-scores', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: username, score }),
      });
      const data = await res.json();
      renderGlobalLeaderboard(data);
    } catch (e) {
      console.error('Global leaderboard update failed', e);
    }
    alert(`Game over, ${username}! Your score: ${score}`);
    for (let y = 0; y < ROWS; y++) board[y].fill(0);
    score = 0; lines = 0; level = 0;
    updateSpeed();
    updateHUD();
    spawn();
  }
  dropCounter = 0;
  lockTimer = 0;
  render();
}

function drop(manual = false) {
  if (tryMove(0, 1) && manual) {
    score += 1;
    updateHUD();
  }
}

function hardDrop() {
  let distance = 0;
  while (isValidPosition(piece.matrix, piece.x, piece.y + 1)) {
    piece.y++;
    distance++;
  }
  if (distance > 0) {
    score += distance * 2;
    updateHUD();
  }
  lockPiece();
}


function update(time = 0) {
  const dt = time - lastTime;
  lastTime = time;

  // Gravity
  dropCounter += dt;
  if (dropCounter >= dropInterval) {
    drop();
    dropCounter = 0;
  }

  // Horizontal movement with DAS/ARR
  if (horiz !== 0) {
    if (dasTimer < DAS) {
      dasTimer += dt;               // wait initial delay
    } else {
      arrTimer += dt;               // then repeat at ARR
      if (arrTimer >= ARR) {
        tryMove(horiz, 0);
        arrTimer = 0;
      }
    }
  }

  // Soft drop (throttled)
  if (keys.down) {
    softTimer += dt;
    if (softTimer >= SOFT) {
      drop(true);
      softTimer = 0;
    }
  } else {
    softTimer = 0;
  }

  // Lock delay
  const grounded = !isValidPosition(piece.matrix, piece.x, piece.y + 1);
  if (grounded) {
    lockTimer += dt;
    if (lockTimer >= LOCK_DELAY) {
      lockPiece();
    }
  } else {
    lockTimer = 0;
  }

  render();
  requestAnimationFrame(update);
}


const keys = { left: false, right: false, down: false };
let horiz = 0;               // -1 left, 0 none, 1 right
let dasTimer = 0;
let arrTimer = 0;
const DAS = 170;             // ms before auto-repeat starts
const ARR = 50;              // ms between repeats after DAS
let softTimer = 0;
const SOFT = 40;             // ms between soft drops

function setHoriz(dir) {
  if (horiz !== dir) {
    horiz = dir;
    dasTimer = 0;
    arrTimer = 0;
    if (dir !== 0) {
      // immediate move on press or when switching directions
      tryMove(dir, 0);
    }
  }
}


window.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowLeft') {
    if (!keys.left) { keys.left = true; setHoriz(-1); }
    e.preventDefault();
  } else if (e.key === 'ArrowRight') {
    if (!keys.right) { keys.right = true; setHoriz(1); }
    e.preventDefault();
  } else if (e.key === 'ArrowDown') {
    keys.down = true; e.preventDefault();
  } else if (e.key === 'x' || e.key === 'X') {
    tryRotate(1); e.preventDefault();
  } else if (e.key === 'z' || e.key === 'Z') {
    tryRotate(-1); e.preventDefault();
  }
  else if (e.code === 'Space') {
    if (!e.repeat) hardDrop(); // ignore key-repeat so it only fires once
    e.preventDefault();
  } else if (e.key === 'c' || e.key === 'C' || e.key === 'Shift') {
    holdPiece(); e.preventDefault();
  }

});

window.addEventListener('keyup', (e) => {
  if (e.key === 'ArrowLeft') {
    keys.left = false;                     // unset first
    setHoriz(keys.right ? 1 : 0);          // then decide continuation
  } else if (e.key === 'ArrowRight') {
    keys.right = false;                    // unset first
    setHoriz(keys.left ? -1 : 0);          // then decide continuation
  } else if (e.key === 'ArrowDown') {
    keys.down = false;
    softTimer = 0;
  }
});
    
const btnLeft = document.getElementById('btn-left');
const btnRight = document.getElementById('btn-right');
const btnRotate = document.getElementById('btn-rotate');
const btnRotateCCW = document.getElementById('btn-rotate-ccw');
const btnDrop = document.getElementById('btn-drop');
const btnHold = document.getElementById('btn-hold');

if (btnLeft && btnRight && btnRotate && btnRotateCCW && btnDrop && btnHold) {
  function bindButton(el, down, up) {
    el.addEventListener('pointerdown', (e) => { e.preventDefault(); down(); });
    el.addEventListener('pointerup', (e) => { e.preventDefault(); if (up) up(); });
    el.addEventListener('pointerleave', () => { if (up) up(); });
  }
  bindButton(btnLeft, () => { keys.left = true; setHoriz(-1); }, () => { keys.left = false; setHoriz(keys.right ? 1 : 0); });
  bindButton(btnRight, () => { keys.right = true; setHoriz(1); }, () => { keys.right = false; setHoriz(keys.left ? -1 : 0); });
  btnRotate.addEventListener('pointerdown', (e) => { e.preventDefault(); tryRotate(1); });
  btnRotateCCW.addEventListener('pointerdown', (e) => { e.preventDefault(); tryRotate(-1); });
  btnDrop.addEventListener('pointerdown', (e) => { e.preventDefault(); hardDrop(); });
  btnHold.addEventListener('pointerdown', (e) => { e.preventDefault(); holdPiece(); });
}

next = getNextPiece();
updateSpeed();
spawn();
updateHUD();
requestAnimationFrame(update);
  </script>
</Layout>
